Phase 1 – Foundation (Binary Tree Basics)
(Goal: Understand tree structure, traversals, and basic properties)

// Level Order Traversal (BFS)
// Preorder / Inorder / Postorder Traversal (DFS)
// Height of Binary Tree
// Count Nodes in Binary Tree
// Check if Binary Tree is Balanced
// Diameter of Binary Tree
// Left View / Right View of Binary Tree
// Top View & Bottom View of Binary Tree
// Zigzag (Spiral) Level Order Traversal
Boundary Traversal (Anti-clockwise)
// Vertical Order Traversal
// Diagonal Traversal

Phase 2 – Core Problem Solving
(Goal: Start applying DFS + BFS for problem solving)
13. Serialize & Deserialize Binary Tree
14. Width of Binary Tree
15. Path Sum I, II, III
16. Maximum Path Sum in Binary Tree
17. Find All Nodes Distance K in Binary Tree
18. Minimum Time to Burn a Binary Tree
19. Longest Zigzag Path in Binary Tree
20. Count Good Nodes in Binary Tree

Phase 3 – BST Fundamentals
(Goal: Learn BST properties and basic operations)
21. Search in BST
22. Insert into BST
23. Delete Node in BST
24. Validate BST
25. Lowest Common Ancestor in BST
26. kth Smallest Element in BST
27. kth Largest Element in BST
28. Range Sum of BST
29. BST Iterator
30. Recover Binary Search Tree

Phase 4 – Tree Construction & Transformations
(Goal: Learn how to construct/transform trees from data)
31. Construct Binary Tree from Preorder & Inorder
32. Construct Binary Tree from Postorder & Inorder
33. Construct BST from Preorder
34. Convert Sorted Array to BST
35. Convert Sorted List to BST
36. Flatten Binary Tree to Linked List
37. Binary Tree to Doubly Linked List
38. BST to Greater Sum Tree

Phase 5 – Advanced Tree Algorithms
(Goal: Apply advanced concepts like rerooting, binary lifting, and tree DP)
39. Tree Diameter (two DFS/BFS method)
40. kth Ancestor in Tree (Binary Lifting)
41. Sum of Distances in Tree (Rerooting DP)
42. Subtree Size Computation
43. Euler Tour of a Tree
44. Dynamic Programming on Trees – Maximum Independent Set
45. Binary Tree Coloring Game
46. Heavy-Light Decomposition Basics
47. Centroid Decomposition

Phase 6 – Competitive Programming Level
(Goal: Solve tough problems that require multiple concepts)
48. Minimum Time to Burn Binary Tree (Optimized)
49. Distance Between Two Nodes in Tree
50. Bridges & Articulation Points in Tree
51. Problems involving Trie in tree problems
52. Problems combining Segment Tree / BIT with Tree
53. Re-rooting DP for sum/min/max queries
54. CSES Tree Problems (Tree Distances I & II, Subordinates, Company Queries I & II)

